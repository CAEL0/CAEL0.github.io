---
title: "[BOJ 11376] 열혈강호 2"
excerpt: Platinum IV
categories: [Problem Solving]
tags: [BOJ, 이분 매칭]
last_modified_at: 2021-08-24 17:51:00 +0900
---

> # 문제
---

[<u>https://www.acmicpc.net/problem/11376</u>](https://www.acmicpc.net/problem/11376)

<br>

> # 풀이
---

이분 매칭으로 풀려면, 직원 노드를 두 배로 늘리기만 하면 된다.

하지만 그렇게 노드와 엣지를 두 배로 늘리면 파이썬 계열은 MLE가 뜬다.

그래서 최대 유량을 구하는 식으로 풀었다.

<br>

> # 코드
---

```python
import sys


def dfs(cur, res):
    if cur == n + m + 1:
        return res
    
    for nxt, capacity in graph[cur]:
        if not visit[nxt]:
            visit[nxt] = 1
            bottleneck = dfs(nxt, min(res, capacity))
            if bottleneck:
                for z in range(len(graph[cur])):
                    if graph[cur][z][0] == nxt:
                        graph[cur][z][1] -= bottleneck
                        if graph[cur][z][1] == 0:
                            graph[cur].remove([nxt, 0])
                        break
                for z in range(len(graph[nxt])):
                    if graph[nxt][z][0] == cur:
                        graph[nxt][z][1] += bottleneck
                        break
                else:
                    graph[nxt].append([cur, bottleneck])
                return bottleneck
    
    return 0


n, m = map(int, sys.stdin.readline().split())
graph = [[] for _ in range(n + m + 2)]

for j in range(n + 1, n + m + 1):
    graph[j].append([n + m + 1, 1])

for i in range(1, n + 1):
    data = list(map(int, sys.stdin.readline().split()))
    if data[0]:
        graph[0].append([i, 2])
        for j in range(1, data[0] + 1):
            graph[i].append([data[j] + n, 1])

ans = 0
flow = 1
while flow:
    visit = [0] * (n + m + 2)
    flow = dfs(0, float('inf'))
    ans += flow

print(ans)
```